{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://version-identifier/./src/extension.ts","webpack://version-identifier/external commonjs \"vscode\"","webpack://version-identifier/webpack/bootstrap","webpack://version-identifier/webpack/startup"],"sourcesContent":["import * as vscode from 'vscode';\n\n// The VersionTag interface defines the structure of the objects that will be used in the versionTags array.\n// Each element of the versionTags array will be an object that describes a single Liquid version tag,\n// and will contain the following properties:\ninterface VersionTag {\n    tagID: number;    // The unique ID of the version tag\n    tagSet: number;   // The ID of the tag set to which the tag belongs\n    positionVersionTagStart: vscode.Position; // The start position of the version tag\n    positionVersionTagEnd: vscode.Position;   // The end position of the version tag\n}\n\n// Create an array to store all of the text decorations that we apply to the editor,\n// so that we can remove them all later in a single operation.\n// We need to declare it here, outside of the activate() function,\n// so that we can it in the deactivate() function\n// at the end of this file.\nlet decorationDefinitionsArray: vscode.TextEditorDecorationType[] = [];\n\n\n// --------------------------------\n// activate() function\n// --------------------------------\nexport function activate(context: vscode.ExtensionContext) {\n\n    // Register a command to run the extension, using a modal dialog box for the version message.\n    let disposableModal = vscode.commands.registerCommand('version-identifier.runExtensionModal', () => {\n        runExtension(true);\n    });\n\n    // Register a command to run the extension, using a \"toast\" popup for the version message.\n    let disposableToast = vscode.commands.registerCommand('version-identifier.runExtensionToast', () => {\n        runExtension(false);\n    });\n\n    // Register a command to remove the decorations.\n    // The command is defined in package.json and is bound to the escape key\n    let removeDecorationsDisposable = vscode.commands.registerCommand(\n            'version-identifier.removeDecorations', () => {\n        // Remove all of the decorations that have been applied to the editor:\n        decorationDefinitionsArray.forEach(decoration => decoration.dispose());\n        decorationDefinitionsArray = []; // Clear the array\n    });\n\n    // Listen for selection changes in the editor\n    let removeDecorationsOnCursorMove =\n    vscode.window.onDidChangeTextEditorSelection(() => {\n        decorationDefinitionsArray.forEach(decoration => decoration.dispose());\n        decorationDefinitionsArray = [];\n    });\n\n    context.subscriptions.push(\n        disposableModal,\n        disposableToast,\n        removeDecorationsDisposable,\n        removeDecorationsOnCursorMove\n    );\n}\n\n// --------------------------------\n// runExtension() function\n// --------------------------------\nfunction runExtension(isModal: boolean) {\n    let activeEditor = vscode.window.activeTextEditor;\n    if (!activeEditor) {\n        return;\n    }\n    // Get the entire text of the active editor\n    const text = activeEditor.document.getText();\n\n    const cursorPosition: vscode.Position = activeEditor.selection.active;\n\n    // Define the arrays we're going to iteratively populate in the parsing loop:\n    let versionTags: VersionTag[] = [];\n    let versionDescription: string[] = [];\n    let elsedVersions: string[] = [];\n    let currentTagSpan: number[] = [];\n    let tagSetID: number[] = [];\n\n    let cursorIsAfterTagStart: Boolean = true; // Set to false when cursor is before the start of the tag during parsing\n    let cursorIsAfterTagEnd: Boolean = true; // Set to false when cursor is before the end of the tag during parsing\n    let tagCounter = 0; // This will be used to assign a unique ID to each ifversion tag\n    let nestingLevel = -1; // Increment each time we encounter an ifversion tag, decrement at each endif tag\n\n    // This regex matches text that starts either\n    // with `{% ifversion ` or `{% elsif `\n    // and ends with ` %}`.\n    // It captures the tag name (ifversion or elsif) in match[1]\n    // and the content between the tag name and the closing bracket\n    // (preceded by one of more spaces) in match[2].\n    const tagRegEx = /\\{%-?\\s*(ifversion|elsif|else|endif)\\s+([^%]*)%\\}/g;\n\n    let match: RegExpExecArray | null;\n    while (match = tagRegEx.exec(text)) {\n        // Search through the entire text for matches of the above regex.\n        // Each loop of this while loop is a match (i.e. a version tag).\n        // For each tag, capture details about the tag in the versionTags array\n        // and store collate version text in the versionDescription array.\n\n        tagCounter++; // Increment the currentTagSpan counter for each tag we encounter\n\n        // Find the start and end positions of the ifversion tag.\n        // match.index is the number of the first character of the match\n        // within the entire searched string (i.e. the entire Markdown file)\n        const openingBracketPos = match.index;\n        const currentTagStart = activeEditor.document.positionAt(openingBracketPos);\n        // match[0] is the matched text (e.g. `{% ifversion ghes %}`).\n        // This gives us the position of the character after the closing bracket\n        const closingBracketPos = match.index + match[0].length;\n        const currentTagEnd = activeEditor.document.positionAt(closingBracketPos);\n\n        // If the cursor position is at or before the start of this tag, set cursorIsAfterTagStart to false.\n        // Note: currentTagStart.translate({ characterDelta: 1 }) adds +1 to the character position.\n        // We need to do this because we want to trigger `false` if the cursor is at the start of the tag\n        // (i.e. the cursor is on the opening bracket rather than inside it).\n        if (cursorIsAfterTagStart && cursorPosition.isBefore(currentTagStart.translate({ characterDelta: 1 }))) {\n            cursorIsAfterTagStart = false;\n        }\n        if (cursorIsAfterTagEnd && cursorPosition.isBefore(currentTagEnd)) {\n            cursorIsAfterTagEnd = false;\n        }\n\n        // Process each type of tag.\n        // match[1] from the regular expression is the tag name (ifversion, elsif, else, or endif)\n        if (match[1] === \"ifversion\") {\n            nestingLevel++;      // Increment the nesting level for each ifversion tag inside an ifversion block\n                                 // Outside of an ifversion block, nestingLevel will be -1\n                                 // In an unnested ifversion block, nestingLevel will be 0\n\n            tagSetID[nestingLevel] = tagCounter; // Set the tagSetID for this ifversion tag\n\n            if (cursorIsAfterTagStart) {\n                currentTagSpan[nestingLevel] = tagCounter; // The cursor may be within this tag\n                if (nestingLevel >0) {\n                    versionDescription[nestingLevel] = \"AND \" + match[2];\n                    elsedVersions[nestingLevel] = \"AND NOT \" + match[2]; // Initialize the list of excluded versions\n                }\n                else {\n                    versionDescription[nestingLevel] = match[2];\n                    elsedVersions[nestingLevel] = \"NOT \" + match[2];\n                }\n            }\n        }\n        else if (match[1] === \"elsif\" && cursorIsAfterTagStart) {\n            currentTagSpan[nestingLevel] = tagCounter; // The cursor may be within this tag\n            if (nestingLevel >0) {\n                versionDescription[nestingLevel] = \"AND \";\n            }\n            versionDescription[nestingLevel] += match[2];\n            elsedVersions[nestingLevel] += \"AND NOT \" + match[2];\n        }\n        else if (match[1] === \"else\" && cursorIsAfterTagStart) {\n            currentTagSpan[nestingLevel] = tagCounter; // The cursor may be within this tag\n            if (nestingLevel >0) {\n                versionDescription[nestingLevel] = \"AND \";\n            }\n            versionDescription[nestingLevel] = elsedVersions[nestingLevel];\n        }\n        else if (match[1] === \"endif\" && cursorIsAfterTagEnd) {\n            elsedVersions.pop();      // Remove the list of excluded versions for the tag set we're leaving\n            versionDescription.pop(); // Remove the version description for the tag set\n            currentTagSpan.pop();     // Remove the tag span for the tag set\n        }\n        // For each tag:\n        // Add the details of the current version tag to the versionTags array.\n        // Each element of the array is an object containing the following properties:\n        versionTags.push({\n            tagID: tagCounter,\n            tagSet: tagSetID[nestingLevel],\n            positionVersionTagStart: currentTagStart,\n            positionVersionTagEnd: currentTagEnd\n        });\n        // At every endif tag in the whole file:\n        if (match[1] === \"endif\") {\n            nestingLevel--;   // Step back out of an ifversion tag set\n        }\n    } // End of the tag parsing loop\n\n    // If there is any versioning at the cursor position:\n    if (currentTagSpan.length > 0) {\n        // Identify and highlight the version tags for the current cursor position:\n        highlightVersionTags(activeEditor, versionTags, currentTagSpan);\n    }\n\n    // Prepare and display the message with versioning information:\n    displayVersionMessage(isModal, cursorPosition, versionDescription);\n\n}  // End of runExtension() function\n\n\n// --------------------------------\n// highlightVersionTags() function\n// --------------------------------\nfunction highlightVersionTags(\n        activeEditor: vscode.TextEditor | undefined,\n        versionTags: VersionTag[],\n        currentTagSpan: number[]\n    ){\n\n    // Get the configuration for 'version-identifier' from the user's settings.json file\n    // (or from the default settings, defined in the extension's in package.json file):\n    let config = vscode.workspace.getConfiguration('version-identifier');\n\n    // From the configuration, get the 'colorPairs' setting,\n    // mapping it to an array of objects with backgroundColor and color properties.\n    // We'll use this to highlight the tags of each tag set at a particular version nesting level.\n    let colorPairs = config.get<{backgroundColor: string, color: string}[]>('colorPairs', []);\n\n    let colorIndex = 0; // This will be used to cycle through the color pairs\n\n    // Iterate through the currentTagSpan array:\n    currentTagSpan.forEach(tagID => {\n        // For each tag span in currentTagSpan array (i.e. the tag span that lets us work out\n        // which tag set we're going to highlight at a particular nesting level),\n        // fetch one pair of colors from the colorPairs array declared at the top of this file.\n        // The modulo operator (%) ensures that if colorIndex is greater than the number of color pairs,\n        // the colors will cycle through the defined pairs.\n        let colors = colorPairs[colorIndex % colorPairs.length];\n\n        // Create a new decoration definition for this color pair\n        let decorationDefinition = vscode.window.createTextEditorDecorationType({\n            backgroundColor: colors.backgroundColor,\n            color: colors.color\n        });\n        decorationDefinitionsArray.push(decorationDefinition);\n\n        // This array will hold the ranges of all the tags in the current tag set:\n        let decorationsArray: vscode.DecorationOptions[] = [];\n\n        // Use the tag span ID to get the tag object for that tag\n        // from the versionTags array:\n        let tagObject = versionTags.find(tag => tag?.tagID === tagID);\n\n        // From this tag object, get its tag set ID:\n        let currentTagSetID = tagObject?.tagSet;\n\n        // Filter the versionTags array,\n        // to find all of the tag objects whose tag set\n        // matches the one we've just found:\n        let matchingTags = versionTags.filter(tag => tag.tagSet === currentTagSetID);\n\n        matchingTags.forEach(tag => {\n            // Create a vscode.Range object for the tag:\n            const range = new vscode.Range(\n                tag.positionVersionTagStart,\n                tag.positionVersionTagEnd\n            );\n\n            // Push the range into the decorationsArray array:\n            decorationsArray.push({ range: range });\n\n        });\n\n        // Apply the decoration to the ranges we've collected for this set of tags.\n        // These will all be highlighted in the same color.\n        if (activeEditor) {\n            activeEditor.setDecorations(decorationDefinition, decorationsArray);\n        }\n        colorIndex++; // Increment the color index so that the next tag set will use a different color pair\n    });\n} // End of highlightVersionTags() function\n\n// --------------------------------\n// displayVersionMessage() function\n// --------------------------------\nfunction displayVersionMessage(isModal: Boolean, cursorPosition: vscode.Position, versionDescription: string[]) {\n\n    // Note: we add +1 to the line and character numbers because they are zero-based:\n    const positionString = ` at the cursor position (line ${(cursorPosition.line + 1)}, character ${(cursorPosition.character + 1)} ) `;\n    let message = \"\";\n\n    if (versionDescription.length === 0) {\n        message = \"There is no inline versioning \" + positionString + \".\";\n    }\n    else {\n        message = \"The inline versioning \" + positionString + \" is:\\n\\n\";\n        for (let description of versionDescription) {\n            message += description + \"\\n\";\n        }\n    }\n\n    if (isModal) {\n        vscode.window.showInformationMessage(\n            message,\n            { modal: true } // Make the popup modal rather than a \"toast\" notification\n        );\n    } else {\n        vscode.window.showInformationMessage(\n            message,\n            \"OK\" // Show a \"toast\" notification with an \"OK\" button\n        );\n    }\n} // End of displayVersionMessage() function\n\n// --------------------------------\n// deactivate() function\n// --------------------------------\n// This function is called when the extension is deactivated.\n// If you deactivate the extension we want to remove any decorations that have been applied.\nexport function deactivate() {\n    decorationDefinitionsArray.forEach(decoration => decoration.dispose());\n    decorationDefinitionsArray = []; // Clear the array\n}\n","module.exports = require(\"vscode\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(112);\n"],"names":["decorationDefinitionsArray","runExtension","isModal","activeEditor","vscode","window","activeTextEditor","text","document","getText","cursorPosition","selection","active","versionTags","versionDescription","elsedVersions","currentTagSpan","tagSetID","cursorIsAfterTagStart","cursorIsAfterTagEnd","tagCounter","nestingLevel","tagRegEx","match","exec","openingBracketPos","index","currentTagStart","positionAt","closingBracketPos","length","currentTagEnd","isBefore","translate","characterDelta","pop","push","tagID","tagSet","positionVersionTagStart","positionVersionTagEnd","colorPairs","workspace","getConfiguration","get","colorIndex","forEach","colors","decorationDefinition","createTextEditorDecorationType","backgroundColor","color","decorationsArray","tagObject","find","tag","currentTagSetID","filter","range","Range","setDecorations","highlightVersionTags","positionString","line","character","message","description","showInformationMessage","modal","displayVersionMessage","context","disposableModal","commands","registerCommand","disposableToast","removeDecorationsDisposable","decoration","dispose","removeDecorationsOnCursorMove","onDidChangeTextEditorSelection","subscriptions","module","exports","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","call"],"sourceRoot":""}